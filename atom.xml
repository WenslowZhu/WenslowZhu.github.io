<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Zhu Ting Blog]]></title>
  <link href="https://wenslowzhu.github.io/atom.xml" rel="self"/>
  <link href="https://wenslowzhu.github.io/"/>
  <updated>2020-03-14T14:25:14+08:00</updated>
  <id>https://wenslowzhu.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Swift - 通过协议 Protocol 共享代码]]></title>
    <link href="https://wenslowzhu.github.io/15841670639825.html"/>
    <updated>2020-03-14T14:24:23+08:00</updated>
    <id>https://wenslowzhu.github.io/15841670639825.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15841670639825/1374191-713f66491d9364f7.jpg" alt="1374191-713f66491d9364f7"/></p>

<p>常用共享代码的方式有：继承、拓展和全局方法。今天笔者分享一种通过 Protocol 共享代码的技巧。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">准备工作</h2>

<p>我们先构建一个类，一个结构体和一个枚举。它们都有一个 <code>String</code> 类型的属性 <code>name</code>。而且它们都有一个叫 <code>printName</code> 的方法，可以用来输出 <code>name</code>。</p>

<pre><code class="language-swift">class PersonClass {
    let name = &quot;David&quot;
    
    func printName(){
        print(name)
    }
}

struct PersonStruct {
    let name = &quot;David&quot;
    
    func printName(){
        print(name)
    }
}

enum PersonEnum {
    var name: String {
        return &quot;David&quot;
    }
    
    case someone
    
    func printName() {
        print(name)
    }
}
</code></pre>

<p>因为 <code>PersonClass</code> ， <code>PersonStruct</code> 和 <code>PersonEnum</code> 的 <code>printName</code> 方法所做的业务是一模一样的，所以把这方法抽离出来放在一个统一的地方，会更方便维护和拓展。</p>

<h2 id="toc_1">构建协议</h2>

<p>我们先构建一个名为 <code>PrintNameProtocol</code> 的协议。在这个协议里我们定义一个 <code>String</code> 类型的接口 <code>name</code>。并在拓展中添加一个具体的实现方法 <code>printName</code>。</p>

<pre><code class="language-swift">protocol PrintNameProtocol {
    var name: String { get }
}

extension PrintNameProtocol {
    func printName() {
        print(name)
    }
}
</code></pre>

<p>接着我们让 <code>PersonClass</code>，<code>PersonStruct</code> 和 <code>PersonEnum</code>  去实现这个协议。</p>

<pre><code class="language-swift">class PersonClass: PrintNameProtocol {
    let name = &quot;David&quot;
}

struct PersonStruct: PrintNameProtocol {
    let name = &quot;David&quot;
}

enum PersonEnum: PrintNameProtocol {
    var name: String {
        return &quot;David&quot;
    }
    
    case someone
}
</code></pre>

<p>因为 <code>PersonClass</code>，<code>PersonStruct</code> 和 <code>PersonEnum</code> 都有 <code>String</code> 类型的属性 <code>name</code>，所以它们都是实现了 <code>PrintNameProtocol</code> 所定义的接口的。接着，我们删除 <code>printName</code> 方法，因为这个方法已经在 <code>PrintNameProtocol</code> 中实现了。</p>

<h2 id="toc_2">使用共享代码</h2>

<p>接着我们初始化一个 <code>personClass</code> 类对象，一个<code>personStruct</code> 结构体和一个枚举 <code>personEnum</code>。并调用一下 <code>printName</code> 方法。</p>

<pre><code class="language-swift">let personClass = PersonClass()
let personStruct = PersonStruct()
let personEnum = PersonEnum.someone

personClass.printName()
personStruct.printName()
personEnum.printName()
</code></pre>

<p>控制台输出：</p>

<pre><code class="language-swift">David
David
David
</code></pre>

<h2 id="toc_3">拓展共享代码</h2>

<p>下面我们再拓展一下 <code>printName</code> 这个方法。</p>

<pre><code class="language-swift">extension PrintNameProtocol {
    func printName() {
        print(&quot;Hello! My name is \(name)&quot;)
    }
}
</code></pre>

<p>重新运行代码后，控制台输出：</p>

<pre><code class="language-swift">Hello! My name is David
Hello! My name is David
Hello! My name is David
</code></pre>

<h2 id="toc_4">小结</h2>

<p>通过拓展协议，我们实现了在类、结构体和枚举中共享代码。这种方式比继承更为灵活和强大。这种共享的方式也方便我们去维护和拓展某些业务代码。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 内存管理之 weak 与 unowned]]></title>
    <link href="https://wenslowzhu.github.io/15841648059621.html"/>
    <updated>2020-03-14T13:46:45+08:00</updated>
    <id>https://wenslowzhu.github.io/15841648059621.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15841648059621/1374191-d95813de95a5db93.jpg" alt="1374191-d95813de95a5db93"/></p>

<p>在用 Swift 做开发时，我们可以使用 <strong>weak</strong> 或是 <strong>unowned</strong> 打破类实例和闭包的强引用循环。今天我们来聊一聊 <strong>weak</strong> 和 <strong>unowned</strong> 的相同和不同之处。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">weak</h2>

<p>日常开发中，我们经常会用 <strong>weak</strong> 来标记代理或者在闭包中使用它来避免引用循环。</p>

<pre><code class="language-swift">weak var delegate: SomeDelegate?

lazy var someClosure: () -&gt; Void = { [weak self] in
    guard let self = self else { retrun }
    self.balabala
}
</code></pre>

<p>当我们赋值给一个被标记 <strong>weak</strong> 的变量时，它的引用计数不会被改变。而且当这个弱引用变量所引用的对象被释放时，这个变量将被自动设为 <strong>nil</strong>。<strong>这也是弱引用必须被声明为 Optional 的原因。</strong></p>

<h2 id="toc_1">unowned</h2>

<p>和 <strong>weak</strong> 相同，<strong>unowned</strong> 也可以在不增加引用计数的前提下，引用某个类实例。</p>

<pre><code class="language-swift">unowned let someInstance: SomeClass

lazy var someClosure: () -&gt; Void = { [unowned self] in
    self.balabala
}
</code></pre>

<p>在使用 <strong>unowned</strong> 时，我们不需要将变量声明为 <strong>Optional</strong>。</p>

<p>需要注意的是。对于被 <strong>unowned</strong> 标记的变量，即使它的原来引用已经被释放，它仍然会保持对被已经释放了的对象的一个 &quot;无效的&quot; 引用，它不是 <strong>Optional</strong> ，也不会被指向 <strong>nil</strong>。所以，当我们试图访问这样的 <strong>unowned</strong> 引用时，程序就会发生错误。</p>

<p>我们看下边这段示例代码：</p>

<pre><code class="language-swift">class SomeSingleton {
    
    static let share = SomeSingleton()
    
    func closure(closure: (() -&gt; Void)?) {
        DispatchQueue.global().asyncAfter(deadline: .now() + 2) {
            closure?()
        }
    }
}

class Person {
    
    let someSingleton = SomeSingleton.share
    let name = &quot;Hello&quot;
    
    func testClosure() {
        someSingleton.closure { [unowned self] in
            print(self.name)
        }
    }
    
    deinit {
        print(&quot;Person is deinited&quot;)
    }
}

class ViewController: UIViewController {
    
    var person: Person?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        person = Person()
        
        person?.testClosure()
        
        person = nil
    }
}
</code></pre>

<p>在这里我们定义了一个单例，这个单例提供一个两秒之后触发的闭包。接着我们又在 <code>Person</code> 这个类中引用这个单例。最后，我们在 <code>ViewController</code> 中实例化一个 <code>Person</code> 对象，并在调用 <code>testClosure()</code> 方法后，将其设为 <strong>nil</strong>。</p>

<p>在程序运行之后，我们观察控制台的 log。<code>person</code> 被 <code>denint</code> 后，控制台打印出了 <code>Person is deinited</code>。在两秒后，单例的闭包被触发，程序尝试访问 <code>person</code> 的 <code>name</code> 属性。由于 <code>person</code> 在此时已经是 <strong>nil</strong>，我们正在尝试读取一个已经被释放，但 <strong>unowned reference</strong> 还存在但对象。所以程序抛出了异常。</p>

<pre><code class="language-text">Person is deinited
Fatal error: Attempted to read an unowned reference but object 0x6000027b5bf0 was already deallocated2019-04-20
</code></pre>

<p>如果我们将 <code>[unowned self]</code> 替换为 <code>[weak self]</code>，再重新运行一遍程序。</p>

<pre><code class="language-swift">someSingleton.closure { [weak self] in
    print(self?.name)
}
</code></pre>

<p>观察控制台的log。在 <code>person</code> 被设置为 <strong>nil</strong> 两秒之后，单例闭包被触发。由于我们在闭包中使用了 <strong>weak</strong>，所以程序不会出错，<code>self?.name</code> 的值为 <strong>nil</strong>。</p>

<pre><code class="language-text">Person is deinited
nil
</code></pre>

<h2 id="toc_2">weak vs. unowned</h2>

<blockquote>
<p>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</p>

<p>Conversely, define a capture as a weak reference when the captured reference may become nil at some point in the future. Weak references are always of an optional type, and automatically become nil when the instance they reference is deallocated. This enables you to check for their existence within the closure’s body.</p>
</blockquote>

<p>根据苹果的官方文档的建议。当我们知道两个对象的生命周期并不相关，那么我们必须使用 <strong>weak</strong>。相反，非强引用对象拥有和强引用对象同样或者更长的生命周期的话，则应该使用 <strong>unowned</strong>。</p>

<p>例如，<code>ViewControler</code> 对它的 <code>SubView</code> 的引用可以使用 <strong>unowned</strong>。因为 <code>ViewControler</code> 的生命周期一定比对它的 <code>SubView</code> 长。</p>

<p>而在使用服务时，则需要看情况使用 <strong>weak</strong>。因为服务的初始化方法可能是被工厂模式或 <strong>Service Locator</strong> 所封装。这些服务可能在某些时候被重构为单例，此时它们的生命周期发生了改变。</p>

<h2 id="toc_3">捕获列表</h2>

<p>除了常用的 <strong>weak self</strong> 和 <strong>unowned self</strong> 之外，我们还可以使用<strong>捕获列表</strong>来打破闭包引用循环。将需要被捕获的变量，用 <strong>weak self</strong> 或 <strong>unowned self</strong> 标记。</p>

<pre><code class="language-swift">someSingleton.closure { [weak portrait] in
    print(portrait)
}

/* 或者 */

someSingleton.closure { [unowned portrait] in
    print(portrait)
}
</code></pre>

<p><strong>捕获列表</strong>也可以用来初始化新的变量</p>

<pre><code class="language-swift">/* 由于 UIImageView(image: portrait) 返回 Optional 的值，
而 unowned 不可以用来标示 Optional 的变量，
所以在这里我们需要强制解包。 */

someSingleton.closure { [unowned imageView = UIImageView(image: portrait)!] in
    print(imageView)
}

/* 或者 */

someSingleton.closure { [weak imageView = UIImageView(image: portrait)] in
    print(imageView)
}
</code></pre>

<p>此时编译器会给出警告。因为这些变量的作用域只在闭包内部。</p>

<pre><code class="language-text">Instance will be immediately deallocated because variable &#39;imageView&#39; is &#39;unowned&#39;

/* 或者 */

Instance will be immediately deallocated because variable &#39;imageView&#39; is &#39;weak&#39;
</code></pre>

<blockquote>
<p>参考：<a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html">Automatic Reference Counting</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Data 的 Delete Rule 详解]]></title>
    <link href="https://wenslowzhu.github.io/15841636525875.html"/>
    <updated>2020-03-14T13:27:32+08:00</updated>
    <id>https://wenslowzhu.github.io/15841636525875.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15841636525875/1374191-1df5dd48c1de988c.jpg" alt="1374191-1df5dd48c1de988"/></p>

<p><strong>Core Data</strong> 是苹果原生自带的数据库管理框架，功能强大但使用起来也很复杂。</p>

<span id="more"></span><!-- more -->

<p>在配置 <strong>Core Data</strong> 的 <strong>relationship</strong> 时有一个属性叫 <strong>Delete Rule</strong>。<strong>Delete Rule</strong> 表明了数据对象在被删除时，和他有 <strong>relationship</strong> 的其他数据对象的处理规则。</p>

<p><img src="https://user-gold-cdn.xitu.io/2019/4/20/16a39e3c6a4ef1d2?w=538&amp;h=558&amp;f=png&amp;s=148770" alt="Delete Rule"/></p>

<h2 id="toc_0">Deny</h2>

<p>除非有 <strong>relationship</strong> 的其他数据对象全部被删除，否则该数据对象将无法被删除。</p>

<blockquote>
<p>你在撤销一个事业部门前，需要先将部门员工全部 fire。</p>
</blockquote>

<h2 id="toc_1">Cascade</h2>

<p>当你删除一个数据对象时，有 <strong>relationship</strong> 的其他数据对象将一并被自动删除。</p>

<blockquote>
<p>你撤销了一个事业部门，该部门的员工在同一时间一并被 fire 。</p>
</blockquote>

<h2 id="toc_2">Nullify</h2>

<p>当你删除一个数据对象时，有 <strong>relationship</strong> 的其他数据对象的 <strong>relationship</strong> 指针将被设置为 <strong>null</strong>。</p>

<p>只有当 <strong>relationship</strong> 是 <strong>Optional</strong> 时，该设置才是有意义的。否则，你必须在删除前，为有 <strong>relationship</strong> 的数据对象手动设置新的 <strong>relationship</strong>。</p>

<h2 id="toc_3">No Action</h2>

<p>正如其名。在删除时，不做对 <strong>relationship</strong> 任何操作。</p>

<p><strong>注意</strong>⚠️</p>

<p>当你使用这种删除规则时，所有的 <strong>relationship</strong> 都需要你手动管理。 </p>

]]></content>
  </entry>
  
</feed>
